#' Need A Title For This Function
#'
#' Performs weighted smooth regression for a given lambda1, lambda2 combination.
#' 
#' @param data An object of class "WTsth.data" as generated by prep()
#' @param lambda1 A scalar numeric. Lambda_1 value to be considered. Provided
#'   value will be transformed to 2^(lambda1).
#' @param lambda2 A scalar numeric Lambda_2 value to be considered. Provided
#'   value will be transformed to 2^(lambda2).
#' @param weight A character. The type of weighting. Must be one of 
#'   eql, keql, wcs, kwcs, wif, kwif indicating
#'   equal weight, K x equal weight, Cosine similarity, K x cosine similarity, 
#'   inverse frequency, and K x inverse frequency, where K is the number of
#'   individuals in each CNVR. 
#' @param family A character. The family of the outcome. Must be one of
#'   "gaussian" (Y is continuous) or "binomial" (Y is binary).
#' @param iter.control A list object. Allows user to control iterative
#'   update procedure. Allowed elements are "max.iter", the maximum number
#'   of iterations; "tol.beta", the difference between consecutive beta
#'   updates below which the procedure is deemed converged; and "tol.loss",
#'   the difference in consecutive loss updates below which the procedure
#'   is deemed converged.
#' @param ... Ignored.
#'
#' @examples
#' 
#' # we need to create a data set and add an example
#' 
#' @returns A numeric vector. The estimated model parameters
#' 
#'
#' @include ctnsSolution.R helpful_tests.R rwlsSolution.R utils.R
#'
#' @export
fit_WTSMTH <- function(data, lambda1, lambda2, weight = NULL,
                       family = c("gaussian", "binomial"), 
                       iter.control = list(max.iter = 8L, 
                                           tol.beta = 10^(-3), 
                                           tol.loss = 10^(-6)),
                       ...) {
  
  extras <- list(...)
  
  # take the first value as default
  family <- match.arg(family)
  
  stopifnot(
    "`data` must be a 'WTsmth.data' object" = !missing(data) && inherits(data, "WTsmth.data"),
    "`lambda1 must be a numeric vector" = !missing(lambda1) && .isNumericVector(lambda1, 1L),
    "`lambda2 must be a numeric vector" = !missing(lambda2) && .isNumericVector(lambda2, 1L),
    "`weight` must be one of eql, keql, wcs, kwcs, wif, kwif" =
      is.null(weight) || {.isCharacterVector(weight, 1L) &&
          weight %in% c("eql", "keql", "wcs", "kwcs", "wif", "kwif")},
    "`iter.control` must be a list; allowed elements are max.iter, tol.beta, and tol.loss" = 
      .isNamedList(iter.control, c("max.iter", "tol.beta", "tol.loss"))
  )
  
  iter.control <- .testIterControl(iter.control)  
  
  if (family == "binomial") data$Y <- .confirmBinary(data$Y)
  if (family == "gaussian") data$Y <- .confirmContinuous(data$Y)
  
  if (is.null(data$XZ)) {
    if (is.null(weight)) stop("`weight` must be provided", call. = FALSE)
    data <- .expandWTsmth(data, weight = weight)
  } else {
    if (!is.null(weight)) warning("`weight` input ignored; data already expanded", call. = FALSE)
  }
  
  if (!is.null(extras$subset)) {
    data$Y <- data$Y[extras$subset]
    data$XZ <- data$XZ[extras$subset, , drop = FALSE]
  }
  
  X_app <- cbind(0.0, sqrt(2.0^lambda2) * data$A)
  rownames(X_app) <- rownames(data$A)
  Y_app <- rep.int(0L, nrow(data$A))
  names(Y_app) <- rownames(data$A)
  
  if (family == "gaussian") {
    .ctnsSolution(data = data, X.app = X_app, Y.app = Y_app, lambda1 = lambda1)
  } else {
    .rwlsSolution(data = data,
                  X.app = X_app, Y.app = Y_app, 
                  lambda1 = lambda1,
                  iter.control = iter.control)
  }
}