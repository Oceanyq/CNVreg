#' Need A Title For This Function
#' 
#' Uses n-fold cross-validation to select the best tuning parameters 
#'   combination.
#'   
#' @param data An object of class "WTsth.data" as generated by prep()
#' @param lambda1 A numeric vector. Lambda_1 values to be considered. Provided
#'   values will be transformed to 2^(lambda1).
#' @param lambda2 A numeric vector Lambda_2 values to be considered. Provided
#'   values will be transformed to 2^(lambda2).
#' @param family A character. The family of the outcome. Must be one of
#'   "gaussian" (Y is continuous) or "binomial" (Y is binary).
#' @param cv.control A list object. Allows user to control cross-validation
#'   procedure. Allowed elements are "n.fold", the number of cross-validation
#'   folds; "n.core", the number of cores to use in procedure; and
#'   "stratified", if TRUE and family = "binomial", the folds will be
#'   stratified (this option should be used if either category is
#'   "rare.")
#' @param iter.control A list object. Allows user to control iterative
#'   update procedure. Allowed elements are "max.iter", the maximum number
#'   of iterations; "tol.beta", the difference between consecutive beta
#'   updates below which the procedure is deemed converged; and "tol.loss",
#'   the difference in consecutive loss updates below which the procedure
#'   is deemed converged.
#'
#'
#' @examples
#' 
#' # need to create dataset and add example code
#' 
#' @returns A list containing the selected lambda values (selected.lambda) and
#'   the model parameter estimates (coef) 
#' 
#' @include helpful_tests.R nfoldSplit.R utils.R Wtsmth_Fit.R
#' @import dplyr
#' @import doParallel
#' @import foreach
#' 
#' @export
cvfit_WTSMTH <- function(data, lambda1, lambda2,
                         family = c("gaussian", "binomial"), 
                         cv.control = list(n.fold = 5L, 
                                           n.core = 1L, 
                                           stratified = FALSE),
                         iter.control = list(max_iter = 8L, 
                                             tol_beta = 10^(-3), 
                                             tol_loss = 10^(-6))) {

  # take the first value as default
  family <- match.arg(family)

  stopifnot(
    "`data` must be a 'WTsth.data' object" = !missing(data) && inherits(data, "WTsth.data"),
    "`lambda1 must be a numeric vector" = !missing(lambda1) && .isNumericVector(lambda1),
    "`lambda2 must be a numeric vector" = !missing(lambda2) && .isNumericVector(lambda2),
    "`cv.control` must be a list; allowed elements are n.fold, n.core, and stratified" = 
      .isNamedList(cv.control, c("n.fold", "n.core", "stratified")),
    "`iter.control` must be a list; allowed elements are max.iter, tol.beta, and tol.loss" = 
      .isNamedList(iter.control, c("max.iter", "tol.beta", "tol.loss")),
  )
  
  iter.control <- .testIterControl(iter.control, family)  
  cv.control <- .testCVControl(cv.control)
  
  if (family == "binomial") data$Y <- .confirmBinary(data$Y)
  
  CNV_info <- data$CNVR.info

  data <- .expandWTsmth(data)
  
  # evaluate loss for all candidates lmd1 + lmd2
  #####################K-fold cross-validation#############

  # nfold split (stratified if indicated)
  tr <- .nfoldSplit(Y = data$Y, cv.control = cv.control)

  loss_matrix <- matrix(0.0, nrow = length(lambda1), ncol = length(lambda2))

  if (cv.control$n.core > 1L) {
    cl <- parallel::makeCluster(cv.control$n.core)
    doParallel::registerDoParallel(cl)
    on.exit(stopCluster(cl))
  }

  idx <- expand.grid(seq_len(cv.control$n.fold), 
                     seq_along(lambda1), 
                     seq_along(lambda2))
  idx_loss <- cbind(idx[, 1L], lambda1[idx[, 2L]], lambda2[idx[, 3L]])

  loss_list <- foreach::foreach(i = seq_len(nrow(idx)), .combine = "rbind") %dopar% {
    
    subset <- tr != idx[i, 1L]

    #fit model
    beta_lmd21 <- Wtsmth_Fit(data = data, 
                             lmd1 = lambda1[idx[i, 2L]], 
                             lmd2 = lambda2[idx[i, 3L]],
                             family = family, 
                             iter.control = iter.control,
                             subset = subset)

    #evaluate loss
    # for continuous this will be a vector(n); for binary it will be scalar
    loss <- .loss(X = data$XZ[subset, ], 
                  Y = data$Y[subset], 
                  beta = beta_lmd21, 
                  family = family)
  }

  idx_loss <- cbind(idx_loss, loss_list) |> data.frame()
  colnames(idx_loss) <- c("fold", "lmd1", "lmd2", "loss")

  #transform the output and take average over folds
  loss_matrix <- idx_loss %>%
    dplyr::group_by(lmd1, lmd2, .drop = FALSE) %>%
    dplyr::summarise(
      avg_loss = mean(loss)
      )
  #best lmd1+lmd2 and coefficients
  Mloss <- arrayInd(which.min(loss_matrix$avg_loss), length(loss_matrix$avg_loss))

  #tunning parameters and beta coefficients
  b_lmd1 = loss_matrix$lmd1[Mloss[1L, 1L]] #row
  b_lmd2 = loss_matrix$lmd2[Mloss[1L, 1L]]#col

  beta_y_cv <- Wtsmth_Fit(XZ = data$XZ, 
                          Y = data$Y, 
                          A_matrix = data$A, 
                          lmd1 = b_lmd1, lmd2 = b_lmd2,
                          family = family, max_iter = max_iter, 
                          end_difbeta = tol_beta, end_difloss = tol_loss)

  list("selected.lambda" = c(b_lmd1, b_lmd2),
       "coef" = beta_y_cv)

}
