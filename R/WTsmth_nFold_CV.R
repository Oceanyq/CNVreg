#' Need A Title For This Function
#' 
#' Uses n-fold cross-validation to select the best tuning parameters 
#'   combination.
#'   
#' @param data An object of class "WTsth.data" as generated by prep()
#' @param lambda1 A numeric vector. Lambda_1 values to be considered. Provided
#'   values will be transformed to 2^(lambda1).
#' @param lambda2 A numeric vector Lambda_2 values to be considered. Provided
#'   values will be transformed to 2^(lambda2).
#' @param weight A character. The type of weighting. Must be one of 
#'   eql, keql, wcs, kwcs, wif, kwif indicating
#'   equal weight, K x equal weight, Cosine similarity, K x cosine similarity, 
#'   inverse frequency, and K x inverse frequency, where K is the number of
#'   individuals in each CNVR
#' @param family A character. The family of the outcome. Must be one of
#'   "gaussian" (Y is continuous) or "binomial" (Y is binary).
#' @param cv.control A list object. Allows user to control cross-validation
#'   procedure. Allowed elements are "n.fold", the number of cross-validation
#'   folds; "n.core", the number of cores to use in procedure; and
#'   "stratified", if TRUE and family = "binomial", the folds will be
#'   stratified (this option should be used if either category is
#'   "rare.")
#' @param iter.control A list object. Allows user to control iterative
#'   update procedure. Allowed elements are "max.iter", the maximum number
#'   of iterations; "tol.beta", the difference between consecutive beta
#'   updates below which the procedure is deemed converged; and "tol.loss",
#'   the difference in consecutive loss updates below which the procedure
#'   is deemed converged.
#'
#'
#' @examples
#' 
#' # need to create dataset and add example code
#' 
#' @returns A list containing the selected lambda values (selected.lambda) and
#'   the model parameter estimates (coef) 
#' 
#' @include helpful_tests.R nfoldSplit.R utils.R Wtsmth_Fit.R
#' @import dplyr
#' @import doParallel
#' @import foreach
#' 
#' @export
cvfit_WTSMTH <- function(data, lambda1, lambda2, weight,
                         family = c("gaussian", "binomial"), 
                         cv.control = list(n.fold = 5L, 
                                           n.core = 1L, 
                                           stratified = FALSE),
                         iter.control = list(max.iter = 8L, 
                                             tol.beta = 10^(-3), 
                                             tol.loss = 10^(-6))) {
  
  # take the first value as default
  family <- match.arg(family)
  
  stopifnot(
    "`data` must be a 'WTsmth.data' object" = !missing(data) && inherits(data, "WTsmth.data"),
    "`lambda1 must be a numeric vector" = !missing(lambda1) && .isNumericVector(lambda1),
    "`lambda2 must be a numeric vector" = !missing(lambda2) && .isNumericVector(lambda2),
    "`weight` must be one of eql, keql, wcs, kwcs, wif, kwif" =
      is.null(weight) || {.isCharacterVector(weight, 1L) &&
          weight %in% c("eql", "keql", "wcs", "kwcs", "wif", "kwif")},
    "`cv.control` must be a list; allowed elements are n.fold, n.core, and stratified" = 
      .isNamedList(cv.control, c("n.fold", "n.core", "stratified")),
    "`iter.control` must be a list; allowed elements are max.iter, tol.beta, and tol.loss" = 
      .isNamedList(iter.control, c("max.iter", "tol.beta", "tol.loss"))
  )
  
  if (family == "binomial")  data$Y <- .confirmBinary(data$Y)
  if (family == "gaussian") data$Y <- .confirmContinuous(data$Y)
  
  iter.control <- .testIterControl(iter.control)  
  cv.control <- .testCVControl(cv.control, family)
  
  
  CNV_info <- data$CNVR.info
 #%%%%%%%%%%%%%%%%%%% 
  if (is.null(data$XZ)) {
    if (is.null(weight)) stop("`weight` must be provided", call. = FALSE)
    data <- .expandWTsmth(data, weight = weight)
  } else {
    if (!is.null(weight)) warning("`weight` input ignored; data already expanded", call. = FALSE)
  }
  
  


  # evaluate loss for all candidates lmd1 + lmd2
  #####################K-fold cross-validation#############
  
  # nfold split (stratified if indicated)
  tr <- .nfoldSplit(Y = drop(data$Y), unique(rownames(data$XZ)), cv.control = cv.control)
  
  loss_matrix <- matrix(0.0, nrow = length(lambda1), ncol = length(lambda2))
  
  if (cv.control$n.core > 1L) {
    cl <- parallel::makeCluster(cv.control$n.core)
    doParallel::registerDoParallel(cl)
    on.exit(parallel::stopCluster(cl))
  }
  
  idx <- expand.grid(seq_len(cv.control$n.fold), 
                     seq_along(lambda1), 
                     seq_along(lambda2))
  idx_loss <- cbind(idx[, 1L], lambda1[idx[, 2L]], lambda2[idx[, 3L]])
  
  i <- NULL # quieting CRAN warning
  
  loss_list <- foreach::foreach(i = seq_len(nrow(idx)), 
                               # .packages = c("WTSMTH"),
                                .combine = "rbind") %dopar% {
                                  track_i <- c(idx[i, 1L], lambda1[idx[i, 2L]], lambda2[idx[i, 3L]])
                                  names(track_i) <- c("fold", "lambda1", "lambda2")
                                  print(track_i)
                                  subset <- tr != idx[i, 1L]
                                  
                                  #fit model
                                  beta_lmd21 <- fit_WTSMTH(data = data, 
                                                           lambda1 = lambda1[idx[i, 2L]], 
                                                           lambda2 = lambda2[idx[i, 3L]],
                                                           family = family, 
                                                           iter.control = iter.control,
                                                           subset = subset)
                                  
                                  #evaluate loss
                                  # for continuous this will be a vector(n); for binary it will be scalar
                                  loss <- .loss(X = data$XZ[!subset, ], 
                                                Y = data$Y[!subset], 
                                                beta = beta_lmd21$coef, 
                                                family = family)
                                }
# X = data$XZ[!subset, ];  Y = data$Y[!subset]; beta = beta_lmd21$coef;  family = family
  idx_loss <- cbind(idx_loss, loss_list) |> data.frame()
  colnames(idx_loss) <- c("fold", "lambda1", "lambda2", "loss")
  
  #transform the output and take average over folds
  loss_matrix <- idx_loss %>%
    dplyr::group_by(lambda1, lambda2, .drop = FALSE) %>%
    dplyr::summarise(
      avg_loss = mean(loss)
    )
  
  #best lmd1+lmd2 and coefficients
  Mloss <- arrayInd(which.min(loss_matrix$avg_loss), length(loss_matrix$avg_loss))
  
  #tunning parameters and beta coefficients
  b_lmd1 = loss_matrix$lambda1[Mloss[1L, 1L]] #row
  b_lmd2 = loss_matrix$lambda2[Mloss[1L, 1L]]#col
  
  beta_y_cv <- fit_WTSMTH(data = data, 
                          lambda1 = b_lmd1, 
                          lambda2 = b_lmd2,
                          family = family, 
                          iter.control = iter.control)
  
  list("selected.lambda" = c(b_lmd1, b_lmd2),
       "coef" = beta_y_cv)
  
}